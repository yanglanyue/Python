"""
    P292【第14天】（加QQ：2250307122领取配套源码资料）
    对象的继承

"""
# ====================================================================================================================== P295【第15天】 单继承
class A():
    def __init__(self):
        self.num = '父类A'

    def print_info(self):
        print(self.num)

class B(A):
    def OK(self):
        return

b = B()
b.print_info()
print(b.num)

# ====================================================================================================================== P296【第15天】 多继承

class AA():
    def __init__(self):
        self.num = '父类AA'

    def print_info(self):
        print(self.num)

# C类继承A类和AA类，当继承的两个类有同名方法，则执行此同名方法的顺序跟继承的先后顺序相关
class C(AA,A):
    def OK(self):
        return

c = C()
c.print_info()

# ====================================================================================================================== P297【第15天】 子类重写继承的父类的属性和方法
class D(AA,A):
    def __init__(self):
        self.num = '重写继承的父类的属性和方法'

    def print_info(self):
        print(self.num)

    def OK(self):
        return

d = D()
d.print_info()

# ====================================================================================================================== P298【第15天】 __mro__ 打印子类继承的父类的关系顺序图
print(D.__mro__)

# ====================================================================================================================== P299~P300【第15天】 子类调用父类同名方法和属性
# ====================================================================================================================== P302~P303【第15天】 super()调用父类方法
# ====================================================================================================================== P304【第15天】 定义私有属性和方法，子类无法访问和使用
# ====================================================================================================================== P305【第15天】 通常习惯性使用get_xxx()和set_xxx()来设置和使用私有属性
# 但在子类调用父类方法是子类必须先调用自己的 __init__ 方法
class E(AA,A):
    def __init__(self):
        self.num = '重写继承的父类的属性和方法'
        # print('但在子类调用父类方法是子类必须先调用自己的 __init__ 方法')

        # ============================================================================================================== 定义私有属性
        self.__age = 0

    # ================================================================================================================== 定义私有方法
    def __print_age(self):
        print(self.__age)

    # ================================================================================================================== 习惯性使用set_xxx()来设置和使用私有属性
    def set_age(self):
        self.__age = 9000

    # ================================================================================================================== 习惯性使用get_xxx()来设置和使用私有属性
    def get_age(self):
        return self.__age

    def print_info(self):
        self.__init__() # 这里加入自己的初始化方法是为了避免之前如果调用过父类初始化方法后，子类自己的方法执行的也将是父类初始化方法中的属性（可将这段代码注释掉看看运行结果）
        print(self.num)

    def fromAA(self):
        # 调用父类方法【方法一】
        AA.__init__(self) # 先调用父类 __init__ 初始化方法以获得其中相关属性
        AA.print_info(self) # 再调用父类相关方法

    def fromA(self):
        A.__init__(self)
        A.print_info(self)
        
        # 调用父类方法【方法二】 格式：super(当前类名,self).方法
        super(E, self).__init__()
        super(E, self).print_info()

    def OK(self):
        return

e = E()
e.fromA()
e.fromAA()
e.print_info()

# ====================================================================================================================== P301【第15天】 多层继承
class EE(E):
    def super_A(self):
        print('super()调用父类的父类，要在父类的方法中先用 super() 方法调用它自己的父类，再用这个子类去调用父类这个含有 super() 的方法')
        super(EE, self).__init__()
        super(EE, self).fromA() # 调用父类的父类，要在父类的方法中先用 super() 方法调用它自己的父类，再用这个子类去调用父类这个含有 super() 的方法

        # 无参数super()
        print('无参数super()调用父类：')
        super().__init__()
        super().fromA()

        # super(EE, self).__print_age()

ee = EE()
ee.print_info()
ee.fromA()
ee.fromAA()
ee.super_A()
print('先调用父类的set_age()方法设定私有属性__age，再调用父类的get_age()方法获取父类的私有属性__age')
ee.set_age()
print(ee.get_age())


# ====================================================================================================================== P308【第14天】 多态
# 子类从写父类方法，不同子类生成的不同对象所从写的继承与父类的方法实现的目的有所不同
class miner():
    def mining(self):
        print('开始挖矿！')

class miner_BTC(miner):
    def mining(self):
        print('挖BTC')

class miner_ETH(miner):
    def mining(self):
        print('挖ETH')

class person():
    def work(self,miner):
        miner.mining()


s19 = miner_BTC()

RTX3090 = miner_ETH()

Tom = person()
Tom.work(s19)
Tom.work(RTX3090)

# ====================================================================================================================== P311【第14天】 类属性
# 实例属性会为每一个创建的实例的属性开辟单独的内存空间，类属性为全类所共有，仅开辟一份内存空间
class dog():
    tooth = 10

wangcai = dog()
xiaohei = dog()

print(dog.tooth)
print(wangcai.tooth)
print(xiaohei.tooth)

# ====================================================================================================================== P312【第14天】 类属性的修改
class cat():
    eyes = '黑色'

afu = cat()
miaomiao = cat()

cat.eyes = '蓝色' # 通过类属性修改类属性，包括类在内的所有实例对象的这个属性都会被修改
print(cat.eyes)
print(afu.eyes)
print(miaomiao.eyes)

miaomiao.eyes = '灰色' # 通过实例属性修改实则是创建了一个实例属性，对这个类或者其他实例对象的这个属性不会产生影响
print(cat.eyes)
print(afu.eyes)
print(miaomiao.eyes)






